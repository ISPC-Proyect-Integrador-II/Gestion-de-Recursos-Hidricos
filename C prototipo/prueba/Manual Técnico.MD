
# ğŸ› ï¸ **Manual TÃ©cnico: Hidroponia Inteligente en ESP32**  

## ğŸ“Œ **1. Arquitectura del Sistema**  

El sistema hidroponÃ­a inteligente estÃ¡ basado en **ESP32**, y se organiza en mÃ³dulos independientes para cada funcionalidad.  
La estructura del cÃ³digo se encuentra organizada en las siguientes carpetas:  

```plaintext
Hidroponia/
â”œâ”€â”€ Hidroponia.ino               # CÃ³digo principal
â”œâ”€â”€ ConfiguraciÃ³n.h              # ConfiguraciÃ³n general
â”œâ”€â”€ ConfiguraciÃ³n_avanzada.h     # ConfiguraciÃ³n avanzada
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ sensores/                # MÃ³dulos de sensores (pH, temperatura, nivel de agua, flujo)
â”‚   â”œâ”€â”€ control/                 # Control automÃ¡tico de riego e iluminaciÃ³n
â”‚   â”œâ”€â”€ pantalla/                # Interfaz de pantalla TFT y menÃºs
â”‚   â”œâ”€â”€ comunicacion/            # Conexiones WiFi, MQTT, BLE Mesh y LoRa Mesh
â”‚   â”œâ”€â”€ rtc/                     # Manejo del reloj RTC
â”‚   â”œâ”€â”€ recetas/                 # GestiÃ³n de recetas de cultivo
â””â”€â”€ bibliotecas/                  # LibrerÃ­as externas necesarias
```

Cada mÃ³dulo es independiente, lo que permite modificar el cÃ³digo sin afectar otras partes del sistema.  

---

## ğŸ“Œ **2. InicializaciÃ³n del Sistema (`setup()`)**  

Cuando el ESP32 se enciende, ejecuta la funciÃ³n `setup()` en `Hidroponia.ino`, donde se realizan las siguientes acciones:  

âœ” **Inicializar pantalla TFT** para mostrar informaciÃ³n visual.  
âœ” **Inicializar sensores** y realizar la primera mediciÃ³n.  
âœ” **Conectar a WiFi y MQTT**, asegurando la comunicaciÃ³n con el servidor.  
âœ” **Activar mÃ³dulos de comunicaciÃ³n** (BLE Mesh y LoRa Mesh).  
âœ” **Cargar recetas almacenadas en EEPROM** y aplicar los parÃ¡metros.  
âœ” **Definir si el nodo funcionarÃ¡ como transmisor o receptor**, segÃºn `transmisor.h` y `receptor.h`.  
âœ” **Inicializar RTC** para manejar la hora y permitir sincronizaciÃ³n.  

---

## ğŸ“Œ **3. Ciclo de OperaciÃ³n (`loop()`)**  

El cÃ³digo ejecuta un ciclo continuo en la funciÃ³n `loop()`, donde se realiza:  

âœ” **ActualizaciÃ³n de la pantalla TFT** con los datos mÃ¡s recientes.  
âœ” **GestiÃ³n de botones fÃ­sicos** para navegar entre los menÃºs.  
âœ” **Lectura de sensores** cada cierto intervalo (ejemplo: 5 segundos).  
âœ” **VerificaciÃ³n de alarmas** si algÃºn valor estÃ¡ fuera de los rangos seguros.  
âœ” **Control automÃ¡tico** de bomba y luces segÃºn condiciones ambientales.  
âœ” **EnvÃ­o de datos** por MQTT si el nodo es transmisor.  
âœ” **RecepciÃ³n y ejecuciÃ³n de comandos** si el nodo es receptor.  
âœ” **SincronizaciÃ³n de fecha y hora con RTC**.  

---

## ğŸ“Œ **4. ComunicaciÃ³n del Sistema**  

### **ğŸ”¹ ConexiÃ³n WiFi y MQTT (`wifi_manager.h` y `comunicacion.h`)**  
- Se inicia WiFi con las credenciales guardadas en EEPROM.  
- Se conecta a un servidor MQTT.  
- Se suscribe a tÃ³picos MQTT para recibir comandos.  
- Si hay desconexiÃ³n, el sistema intenta reconectar automÃ¡ticamente.  

### **ğŸ”¹ ComunicaciÃ³n BLE Mesh (`ble_mesh.h`)**  
- Se configura un servidor BLE.  
- Se define un servicio y caracterÃ­stica para enviar y recibir datos.  
- Cuando otro ESP32 envÃ­a datos, la funciÃ³n `onWrite()` los procesa y ejecuta acciones.  

### **ğŸ”¹ ComunicaciÃ³n LoRa Mesh (`lora_mesh.h`)**  
- Se inicializa el mÃ³dulo LoRa.  
- Se define una funciÃ³n para **enviar paquetes de datos LoRa** a otros nodos.  
- Se procesa la recepciÃ³n de datos entrantes para ejecutar acciones en el nodo receptor.  

---

## ğŸ“Œ **5. Modo Transmisor y Modo Receptor**  

ğŸ“¡ **Modo Transmisor (`transmisor.h`)**  
âœ” Recoge datos de los sensores.  
âœ” EnvÃ­a los datos a otros dispositivos vÃ­a MQTT, LoRa o BLE.  

ğŸ¯ **Modo Receptor (`receptor.h`)**  
âœ” Recibe datos de otros nodos.  
âœ” Procesa los mensajes y ejecuta comandos (por ejemplo, activar iluminaciÃ³n).  

Estos modos pueden activarse o desactivarse con la variable `esNodoTransmisor` o `esNodoReceptor`.  

---

## ğŸ“Œ **6. Almacenamiento de Recetas de Cultivo en EEPROM**  

Las recetas de cultivo se guardan en EEPROM y permiten modificar los parÃ¡metros sin necesidad de reprogramar el cÃ³digo.  

âœ” **Estructura de receta (`recetas.h`)**  
```cpp
struct Receta {
    char nombre[20];
    float tempAgua;
    float tempAire;
    float humedad;
    float nivelAgua;
    float ph;
    bool iluminacion;
};
```
âœ” **Carga y guardado en EEPROM (`recetas.cpp`)**  
```cpp
void cargarRecetas() {
    EEPROM.begin(512);
    EEPROM.get(0, recetas);
}
void guardarRecetas() {
    EEPROM.put(0, recetas);
    EEPROM.commit();
}
```

---

## ğŸ“Œ **7. ExpansiÃ³n del Sistema (Agregar Sensores y Mejoras)**  

Para **agregar un sensor nuevo**, sigue estos pasos:  
1ï¸âƒ£ **Define el pin en `sensores.h`**  
2ï¸âƒ£ **Crea una funciÃ³n de lectura en `sensores.cpp`**  
3ï¸âƒ£ **Modifica `loop()` en `Hidroponia.ino`** para llamar a la funciÃ³n periÃ³dicamente.  
4ï¸âƒ£ **Si es necesario, envÃ­a los datos por MQTT en `transmisor.cpp`**  

Ejemplo para un sensor de CO2:  

### **Archivo: `sensores.h`**  
```cpp
#define SENSOR_CO2_PIN 37
```

### **Archivo: `sensores.cpp`**  
```cpp
float leerCO2() {
    return analogRead(SENSOR_CO2_PIN) * 0.1;
}
```

### **ModificaciÃ³n en `loop()` (`Hidroponia.ino`)**  
```cpp
float co2 = leerCO2();
Serial.println("CO2: " + String(co2));
```

### **EnvÃ­o de datos MQTT en `transmisor.cpp`**  
```cpp
String datos = "{\"CO2\":" + String(co2) + "}";
client.publish("hidroponia/datos", datos.c_str());
```

---

## ğŸ“Œ **8. Agregar Nuevas Automatizaciones**  

Para **agregar una automatizaciÃ³n**, por ejemplo, ajuste de nutrientes segÃºn el pH:  

### **Archivo: `control.h`**  
```cpp
void ajustarNutrientes();
```

### **Archivo: `control.cpp`**  
```cpp
void ajustarNutrientes() {
    if (phValor < 5.8) {
        Serial.println("Agregando nutrientes alcalinos.");
    } else if (phValor > 7.2) {
        Serial.println("Agregando nutrientes Ã¡cidos.");
    } else {
        Serial.println("pH dentro del rango Ã³ptimo.");
    }
}
```

### **Llamada en `loop()` (`Hidroponia.ino`)**  
```cpp
ajustarNutrientes();
```

---

